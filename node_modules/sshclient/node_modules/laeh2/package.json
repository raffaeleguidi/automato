{
  "author": {
    "name": "Juraj Vitko",
    "url": "ypocat.com"
  },
  "name": "laeh2",
  "description": "Lightweight Asynchronous Error Handling v2",
  "keywords": [
    "error",
    "handling",
    "asynchronous"
  ],
  "version": "0.3.3",
  "homepage": "http://github.com/ypocat/laeh2",
  "repository": {
    "type": "git",
    "url": "git://github.com/ypocat/laeh2.git"
  },
  "main": "./lib/laeh2.js",
  "directories": {
    "lib": "./lib"
  },
  "engines": {
    "node": ">= 0.4.0"
  },
  "dependencies": {},
  "devDependencies": {},
  "licenses": [
    {
      "type": "MIT",
      "url": "https://raw.github.com/ypocat/laeh2/master/LICENSE"
    }
  ],
  "readme": "# Lightweight Asynchronous Error Handling v2 for Node.js (LAEH2)\n\n### News for 0.3.1\n\n`_e()` can now optionally be used as `_e('some string with %s formatting', 'nice')`.\n\n## Important Changes for >= 0.3.0\n\n### Change 1\n\nThe `_x()` and `_e()` functions are no longer placed to the global space, and you need to explicitly declare them in your module as `var _x = laeh2._x;` and `var _e = laeh2._e;` (that is, if you need to use `_e` at all).\n\nThe reason for this is that in some situations, Node/V8 had trouble to garbage-collect data created in functions wrapped by the `_x()` function, although this works perfectly fine when you reassign the `_x` function locally in your module.\n\nThis change breaks existing code, but it's very easy to fix. Bug report for Node/V8 for this issue wasn't filled yet.\n\n### Change 2\n\nThe `capturePrevious` flag now defaults to the opposite of `process.env.NODE_ENV === 'production'`, which means that if you want to have asynchronous stack-traces captured in production, you need to use `.capturePrevious(true)` explicitly.\n\nAnother change here is that when `capturePrevious` is `true`, the stack-traces are no longer stored inside Error instances, but serialized during the capturing phase. This solves another mysterious garbage-collecting problem, similar to the one described above. This also adds a tiny extra overhead to the capturing phase.\n\n\n## Evolution\n\n### 1. Unprotected callback code\n\n```js\nfunction someContext(arg, arg, callback) {\n\n\tasyncFunction(arg, arg, function(err, data) {\n\t\t// err is not checked but should be (a common case)\n\t\tthrow new Error('fail'); // uncaught - will exit Node.js\n\t}\n\n}\n```\n\n### 2. Manualy protected callback code, lots of clutter\n\n```js\nfunction someContext(arg, arg, callback) {\n\n\tasyncFunction(arg, arg, function(err, data) {\n\t\tif(err)\n\t\t\tcallback(err);\n\t\telse {\n\t\t\ttry {\n\t\t\t\tthrow new Error('fail');\n\t\t\t}\n\t\t\tcatch(e) {\n\t\t\t\tcallback(e); // caught - return control manually\n\t\t\t}\n\t\t}\n\t}\n\n}\n```\n\n### 3. LAEH2, an elegant solution\n\n```js\nfunction someContext(arg, arg, callback) {\n\n\tasyncFunction(arg, arg, _x(callback, true, function(err, data) {\n\t\tthrow new Error('fail');\n\t}));\n}\n```\n\nParameters for the `_x` LAEH2 wrapper function:\n\n* `callback`: in case of error, return control to callback (if you pass `null`, the callback will be taken from the last parameter of the function in the third argument, if that parameter is a `function`\n* `true`: automatically check callback's err parameter and pass it directly to the parent callback if true\n* `function`: the asynchronously executed callback function to wrap\n\n\n### 4. Optional Goodies\n\nLAEH2 stores the stacktrace of the thread that initiated the asynchronous operation which in turn called the callback. This stacktrace is then appended to the primary stacktrace of the error which was thrown in the callback, or the error which was passed to the callback by the asynchronous function.\n\nLAEH2 then presents the stacktrace in a minified format, with optional hiding of frames of the `laeh2.js` itself, of the Node.js' core library files, shortens the often repeating string `/node_modules/` into `/$/`, and removes the current directory path prefix from the file names in the stacktrace.\n\n\n## Usage\n\nInstall LAEH2:\n\n\tnpm install laeh2\n\nAnd then wrap your asynchronous callback with the `_x` function:\n\n```js\nvar fs = require('fs');\nvar laeh = require('laeh2').leanStacks(true);\nvar _e = laeh._e;\nvar _x = laeh._x;\n\nvar myfunc = function(param1, paramN, cb) {\n\tfs.readdir(__dirname, _x(cb, true, function(err, files) { // LINE #7\n\t\t// do your things here..\n\t\t_e('unexpected thing'); // throw your own errors, etc. LINE #9\n\t}));\n}\n\nmyfunc('dummy', 'dummy', function(err) { // LINE #13\n\tif(err)\n\t\tconsole.log(err.stack);\n});\n```\n\nThis will print:\n\n\tunexpected thing < ./ex1.js(9) << ./ex1.js(7 < 13)\n\nThe async boundary is (by default) marked with `<<`.\n\nIf we disable the \"hiding\" by passing `false` as the first parameter, the output will be something like:\n\n\tunexpected thing < /Users/ypocat/Github/laeh2/lib/laeh2.js(31) < ./ex1.js(9) < /Users/ypocat/Github/laeh2/lib/laeh2.js(56) << /Users/ypocat/Github/laeh2/lib/laeh2.js(45) < ./ex1.js(7 < 13) < module.js(432 < 450 < 351 < 310 < 470) < node.js(192)\n\nIf we enable hiding, and add some metadata:\n\n```js\n_e('unexpected thing', { msg: 'my metadata', xyz: 123 });\n```\n\n..the output, when configured with `.leanStacks(true, '\\t')`, will be:\n\n\tunexpected thing < {\n\t        \"msg\": \"my metadata\",\n\t        \"xyz\": 123\n\t} ./ex2.js(9) << ./ex2.js(7 < 13)\n\nAnd when configured with just `.leanStacks(true)`:\n\n\tunexpected thing < {\"msg\":\"my metadata\",\"xyz\":123} ./ex3.js(9) << ./ex3.js(7 < 13)\n\nThis is a nice terse format which is also good when you store error messages to database or services like Loggly (with JSON input), as it saves a lot of space.\n\nFor comparison, this would be printed without using `.leanStacks`:\n\n\tError: unexpected thing\n\t    at /Users/ypocat/Github/laeh2/lib/laeh2.js:31:8\n\t    at /Users/ypocat/Github/laeh2/example/ex4.js:9:3\n\t    at Object.oncomplete (/Users/ypocat/Github/laeh2/lib/laeh2.js:56:9)\n\n(Notice that the parent stack trace is missing.)\n\nThe `leanStacks(hiding, prettyMeta)` call is optional, the `hiding` will hide stack frames from Node's core .js files and from `laeh2.js` itself. The `prettyMeta` is the third parameter for the `JSON.stringify` function, which is used to serialize your metadata objects (see below), and leaving it empty or null will serialize your metadata objects in-line.\n\nAdded in LAEH2 are 2 new parameters to `.leanStacks`: `frameSeparator` and `fiberSeparator`, which default to `' < '` and `' << '`, respectively. But if you use tools which rely on the newlines in your stack traces, you can set these accordingly, e.g. to `'\\n'` and `'\\n<<\\n'`, respectively, e.g. `.leanStacks(true, null, '\\n', '\\n<<\\n')`:\n\n\tunexpected thing\n\t./ex6.js(9)\n\t<<\n\t./ex6.js(7 < 13)\n\n### Notes\n\nIf you don't want a new Error object to be created each time a function wrapped by `_x()` is called (you are OK to lose the stack-trace of the async caller), use the following call:\n\n```js\nvar laeh = require('laeh2').capturePrevious(false);\n\n// you can also chain these, e.g.:\n\nvar laeh = require('laeh2').capturePrevious(false).leanStacks(true);\n```\n\n### Warning\n\nDon't use LAEH to wrap non-asynchronous callbacks, and especially non-asynchronous loop callbacks, as this can lead to nasty runtime errors. Consider e.g.:\n\n```js\n[ 'one', 'two', 'three' ].forEach(_x(cb, false, function(v) {\n\tthrow new Error('unexpected');\n}));\n```\n\nThis will call the `cb` callback three times (effectively forking your control flow), because the `Array.forEach()` will not stop looping when the callback is called. Correct approach here is to not wrap the synchronous callback in `_x`, and let the parent block (which should be protected by `_x`, by `try/catch`, or by its synchronous parent block) handle any exceptions.\n\n### Express.js\n\nWhen coding handlers or params for Express.js or Connect, just pass the `next` parameter as the eventual callback, e.g.:\n\n```js\napp.param('reg', function(req, res, next, email) {\n\tdb.hgetall('reg:' + email, _x(next, true, function(err, reg) {\n\t\tif(!reg.lickey)\n\t\t\treturn next('No such registration');\n\t\treq.reg = reg;\n\t\tnext();\n\t}));\n});\n```\n\nNow any error thrown in the callback called by Redis' `hgetall` will be captured and passed to the `next()` function. Likewise, should Redis respond with an error passed via the `err` parameter, this parameter is automatically checked and the error will be passed to the `next()` function. Easy peasy LAEH squeezy.\n\nNote: There is no need to `_x`-wrap the callback passed to the `app.param()` call (or `app.get()` etc.), as Express.js wraps and handles this first level automatically.\n\n### Other\n\nThe `_e(err, meta)` function is just a convenient error checking, wrapping and throwing. E.g. `_e('something')` will throw `new Error('something')` and `_e(null)` will not do anything. The `meta` parameter is an optional accompanying information for the error to be thrown, which is then displayed when you let LAEH to display your errors using the `leanStacks()` call.\n\nIn the `_x(cb, chk, func)`, the func is your callback to be wrapped. If it follows the node convention of `func(err, args)`, you can pass `chk` as true, which will automatically check for the `err` to be null, and call the eventual callback if it isn't null. The eventual callback is passed as the `cb` argument, or if omitted, it is tried to be derived from the last argument passed to the function you are wrapping, e.g. if the signature is `func(err, args, cb)`, the `cb` is taken from its arguments.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/ypocat/laeh2/issues"
  },
  "_id": "laeh2@0.3.3",
  "_from": "laeh2@*"
}
